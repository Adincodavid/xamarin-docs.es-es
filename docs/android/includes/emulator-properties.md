|Property|Descripción|Opciones|
|--- |--- |--- |
|`abi.type`|**Tipo de ABI** &ndash; especifica el tipo ABI (interfaz binaria de aplicaciones) del dispositivo emulado. El **x86** opción está habilitada la instrucción establecer suelen denominarse "x86" o "IA-32." El **x86_64** opción está habilitada la x86 64 bits conjunto de instrucciones. El **armeabi v7a** opción es para el conjunto con extensiones v7-a ARM de instrucciones de ARM. El **arm64 v8a** opción es para el conjunto de instrucciones de ARM que admite AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Almacenar en caché partición** &ndash; determina si el dispositivo emulado utiliza un **/caché** partición en el dispositivo. El **/caché** partición (que inicialmente está vacía) es la ubicación donde Android almacena datos de acceso frecuente y los componentes de aplicación. Si establecido en **ningún**, el emulador no se usará un **/almacenar en memoria caché** partición y el otro `disk.cache` se omitirá la configuración.|sí, no|
|`disk.cachePartition.path`|**Ruta de acceso de caché partición** &ndash; especifica un archivo de imagen de la partición de memoria caché en el equipo de desarrollo. El emulador utilizará este archivo para la **/caché** partición. Escriba una ruta de acceso absoluta o una ruta de acceso relativa al directorio de datos del emulador. Si no se establece, el emulador crea un archivo temporal vacío denominado **cache.img** en el equipo de desarrollo. Si el archivo no existe, se crea como un archivo vacío. Esta opción se omite si `disk.cachePartition` está establecido en **sin**.||
|`disk.cachePartition.size`|**Tamaño de partición de la caché** &ndash; el tamaño del archivo de partición de memoria caché (en megabytes). Normalmente no es necesario establecer esta opción, a menos que la aplicación vaya a descargar archivos mayores que el tamaño de caché predeterminado, de 66 megabytes. Esta opción se omite si `disk.cachePartition` está establecido en **sin**.||
|`disk.dataPartition.initPath`|**Ruta de acceso inicial para la partición de datos** &ndash; especifica el contenido inicial de la partición de datos. Después de borrar datos de usuario, el emulador copia el contenido del archivo especificado a los datos de usuario (de forma predeterminada, **userdata qemu.img**) en lugar de usar **userdata.img** como la versión inicial.||
|`disk.dataPartition.path`|**Ruta de acceso a la partición de datos** &ndash; especifica el archivo de partición de datos de usuario. Para configurar un archivo de datos de usuario persistentes, escriba un nombre de archivo y una ruta de acceso en el equipo de desarrollo. Si el archivo no existe, el emulador crea una imagen desde el archivo predeterminado **userdata.img**, lo almacena en el nombre de archivo especificado por `disk.dataPartition.path`, y conserva los datos de usuario a ella cuando se cierra el emulador. Si no se especifica una ruta de acceso, el archivo predeterminado se denomina **qemu.img userdata**. El valor especial  **<temp>**  hace que el emulador crear y utilizar un archivo temporal. Si `disk.dataPartition.initPath` está establecido, su contenido se copiará en el archivo disk.dataPartition.path en tiempo de arranque. Tenga en cuenta que esta opción no puede dejarse en blanco.||
|`disk.dataPartition.size`|**Tamaño de partición de datos** &ndash; especifica el tamaño de la partición de datos de usuario en megabytes.||
|`disk.ramdisk.path`|**Ruta de acceso de RAMDisk** &ndash; ruta de acceso a la imagen de (disco RAM) de la partición de arranque. La imagen de disco RAM es un subconjunto de la imagen del sistema que el kernel carga antes de que se monte la imagen del sistema. La imagen de disco RAM suele contener archivos binarios de tiempo de arranque y scripts de inicialización. Si no se especifica esta opción, el valor predeterminado es **ramdisk.img** en el directorio de sistema del emulador.||
|`disk.snapStorage.path`|**Ruta de acceso de almacenamiento de instantáneas** &ndash; ruta de acceso al archivo de almacenamiento de instantáneas se almacenan todas las instantáneas. En este archivo se guardarán todas las instantáneas realizadas durante la ejecución. Únicamente se pueden restaurar durante la ejecución del emulador las instantáneas guardadas en este archivo. Si no se especifica esta opción, el valor predeterminado es snapshots.img en el directorio de datos del emulador.||
|`disk.systemPartition.initPath`|**Ruta de acceso del sistema partición init** &ndash; ruta de acceso a la copia de sólo lectura del archivo de imagen del sistema; en concreto, la partición que contiene las bibliotecas del sistema y los datos correspondientes en el nivel de API y cualquier variante. Si no se especifica esta ruta de acceso, el valor predeterminado es system.img en el directorio de sistema del emulador.||
|`disk.systemPartition.path`|**Ruta de acceso de partición de sistema** &ndash; ruta de acceso a la imagen de partición de sistema de lectura/escritura. Si no se establece esta ruta de acceso, se crea un archivo temporal y se inicializa con el contenido del archivo especificado por `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Tamaño de la partición de sistema** &ndash; el tamaño ideal de la partición del sistema (en megabytes). El tamaño se omite si la imagen de la partición del sistema real es mayor que esta configuración; en caso contrario, se especifica el tamaño máximo que puede alcanzar el archivo de partición del sistema.||
|`hw.accelerometer`|**Acelerómetro** &ndash; determina si el dispositivo emulado contiene un sensor acelerómetro. El acelerómetro ayuda al dispositivo a determinar orientación (usada para el giro automático). El acelerómetro informa de la aceleración del dispositivo a través de tres ejes de sensor.|sí, no|
|`hw.audioInput`|**Compatibilidad de grabación de audio** &ndash; determina si el dispositivo emulado puede grabar audio.|sí, no|
|`hw.audioOutput`|**Compatibilidad con la reproducción de audio** &ndash; determina si el dispositivo emulado puede reproducir audio.|sí, no|
|`hw.battery`|**Compatibilidad con batería** &ndash; determina si el dispositivo emulado puede ejecutarse en una batería.|sí, no|
|`hw.camera`|**Compatibilidad con la cámara** &ndash; determina si el dispositivo emulado tiene una cámara.|sí, no|
|`hw.camera.back`|**Cámara orientados hacia atrás** &ndash; configura la cámara orientados hacia atrás (las caras de lente alejándose del usuario). Si utilizas una cámara Web en el equipo de desarrollo para simular la cámara orientados hacia atrás en el dispositivo emulado, este valor debe establecerse en la cámara Web*n*, donde _n_ selecciona la cámara Web (si tiene sólo una cámara Web Elija **webcam0**). Si emula establecido en, el emulador simula el software de la cámara. Para deshabilitar la cámara orientados hacia atrás, establezca este valor en ninguno. Si habilita la cámara orientados hacia atrás, asegúrese de habilitar `hw.camera`.|emulado, ninguno, webcam0|
|`hw.camera.front`|**Cámara frontal** &ndash; configura la cámara frontal (las caras de lente hacia el usuario). Si utilizas una cámara Web en el equipo de desarrollo para simular la cámara frontal del dispositivo emulado, este valor debe establecerse en la cámara Web*n*, donde _n_ selecciona la cámara Web (si tiene sólo una cámara Web Elija **webcam0**). Si emula establecido en, el emulador simula una software de la cámara. Para deshabilitar la cámara frontal, establezca este valor en none. Si habilita la cámara frontal, asegúrese de habilitar `hw.camera`.|emulado, ninguno, webcam0|
|`hw.camera.maxHorizontalPixels`|**Píxeles de cámara horizontal máximo** &ndash; configura la máxima resolución horizontal de la cámara del dispositivo emulado (en píxeles).||
|`hw.camera.maxVerticalPixels`|**Píxeles de cámara vertical máximo** &ndash; configura la resolución vertical máxima de la cámara del dispositivo emulado (en píxeles).||
|`hw.cpu.arch`|**Arquitectura de CPU** &ndash; arquitectura de la CPU para emular el dispositivo virtual. Si usas HAXM de Intel para la aceleración de hardware, seleccione **x86** para una CPU de 32 bits. Seleccione **x86_64** para un dispositivo y acelerados por HAXM de 64 bits. (Asegúrese de instalar la imagen del sistema Intel x86 correspondiente en el Administrador de SDK: por ejemplo, Intel x86 Atom o Intel x86 Atom_64.) Para simular una CPU ARM, seleccione **arm** de 32 bits o seleccione **arm64** para una CPU de ARM de 64 bits. Tenga en cuenta que los dispositivos virtuales basados en ARM se ejecutarán mucho más lentamente que los basados en x86, ya que la aceleración de hardware no está disponible para ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modelo de la CPU** &ndash; normalmente se deja sin establecer este valor (se establecerá en un valor que se deriva de `hw.cpu.arch` si no se establece explícitamente). A pesar de ello, se puede establecer en una cadena específica del emulador para su uso experimental.||
|`hw.dPad`|**Las claves de DPad** &ndash; determina si el dispositivo emulado admite teclas del teclado direccional (DPad). Un DPad suele tener cuatro teclas para indicar el control direccional.|sí, no|
|`hw.gps`|**Admitir GPS** &ndash; determina si el dispositivo emulado tiene un receptor GPS (sistema de posicionamiento Global).|sí, no|
|`hw.gpu.enabled`|**Emulación de GPU** &ndash; determina si el dispositivo emulado admite la emulación de GPU. Cuando está habilitada, la emulación de GPU usa OpenGL para sistemas incrustados (OpenGL ES) para representar gráficos 2D y 3D en la pantalla, y la configuración del modo de emulación de GPU asociada determina cómo se implementa la emulación de GPU.|sí, no|
|`hw.gpu.mode`|**Modo de emulación de GPU** &ndash; determina cómo se implementa la emulación de GPU por el emulador. Si selecciona automático, el emulador elegirá la aceleración de hardware y software según la configuración del equipo de desarrollo. Si selecciona el host, el emulador utilizará procesador de gráficos de su equipo de desarrollo para realizar la emulación de GPU para un procesamiento más rápido. Si no es compatible con el emulador de la GPU y está en Windows, puede intentar ángulo en lugar de host. El modo de ángulo utiliza DirectX para ofrecer un rendimiento similar al host. Si selecciona mesa, el emulador utilizará la biblioteca de software 3D Mesa para representar gráficos. Seleccione mesa si tiene problemas de representación a través de procesador de gráficos de su equipo de desarrollo. El modo de swiftshader puede usarse para representar gráficos en el software con un rendimiento ligeramente menor que el uso de GPU de su equipo. La opción off (emulación de hardware de gráficos disable) es una opción en desuso que puede causar la representación incorrecto para algunos elementos y, por lo tanto, no se recomienda.|automático, host, mesa, ángulo, swiftshader, desactivado|
|`hw.gsmModem`|**Compatibilidad con un módem GSM** &ndash; determina si el dispositivo emulado incluye un módem que admite el sistema de radio de telefonía GSM (sistema Global para comunicaciones móviles).|sí, no|
|`hw.initialOrientation`|**Orientación de la pantalla de inicial** &ndash; configura la orientación inicial de la pantalla en el dispositivo emulado (modo vertical u horizontal). En el modo vertical, la pantalla es más alta que ancha. En el modo horizontal, la pantalla es más ancha que alta. Cuando se ejecuta el dispositivo emulado, puede cambiar la orientación si se admiten en el perfil del dispositivo el modo vertical y horizontal.|vertical, horizontal|
|`hw.keyboard`|**Teclado compatible con** &ndash; determina si el dispositivo emulado admite un teclado QWERTY.|sí, no|
|`hw.keyboard.charmap`|**Nombre del teclado charmap** &ndash; el nombre de la charmap de hardware para este dispositivo. Nota: Debe ser siempre el valor predeterminado **qwerty2** a menos que haya modificado la imagen del sistema en consecuencia. Este nombre se envía al kernel en el momento del arranque. Si se especifica un nombre incorrecto, el dispositivo virtual no se podrá usar.||
|`hw.keyboard.lid`|**Teclado compatible con tapa** &ndash; si está habilitada la compatibilidad con el teclado, esta configuración determina si el teclado QWERTY puede estar cerrado/oculta o abrir visible. Esta opción se omitirá si hw.keyboard está establecida en false. Nota: el valor predeterminado es false si el dispositivo emulado está destinado a nivel de API 12 o superior.|sí, no|
|`hw.lcd.backlight`|**Contraluz LCD** &ndash; determina si una luz de fondo de LCD se simula el dispositivo emulado.|sí, no|
|`hw.lcd.density`|**Densidad de LCD** &ndash; la densidad de la pantalla LCD emulada, medida en píxeles independientes del densidad o punto de distribución (dp es una unidad virtual píxeles). Si el valor es 160 dp, cada dp se corresponde con un píxel físico. En tiempo de ejecución, Android usa este valor para seleccionar y escalar los recursos/activos adecuados para la representación correcta de la pantalla.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profundidad de color LCD** &ndash; la profundidad de bits del color del búfer de fotogramas emulado que contiene el mapa de bits para impulsar la pantalla LCD. Este valor puede ser 16 bits (65 536 colores posibles) o 32 bits (16 777 216 colores más transparencia). El valor de 32 bits puede hacer que el emulador se ejecute un poco más lentamente, pero con una mayor precisión del color.|16, 32|
|`hw.lcd.height`|**Alto de píxel de LCD** &ndash; el número de píxeles que componen la dimensión vertical de la pantalla LCD emulada.||
|`hw.lcd.width`|**Ancho de píxel de LCD** &ndash; el número de píxeles que componen la dimensión horizontal de la pantalla LCD emulada.||
|`hw.mainKeys`|**Claves de hardware Back/Home** &ndash; determina si el dispositivo emulado admite el hardware nuevo y botones de navegación principal. Puede establecer este valor en **Sí** si los botones solo están implementados en software. Si `hw.mainKeys` está establecido en **Sí**, el emulador no mostrará los botones de navegación en la pantalla, pero puede usar el panel lateral del emulador "presionar" estos botones.|sí, no|
|`hw.ramSize`|**Tamaño de RAM de dispositivo** &ndash; la cantidad de RAM física en el dispositivo emulado, en megabytes. El valor predeterminado se calcula a partir del tamaño de la pantalla o de la versión de la máscara. Si se aumenta el tamaño, el emulador puede funcionar más rápidamente, pero a cambio solicitará más recursos al equipo de desarrollo.||
|`hw.screen`|**Toque la pantalla, escriba** &ndash; define el tipo de pantalla en el dispositivo emulado. Una pantalla de multitoque puede realizar un seguimiento dedos dos o más en la interfaz de entrada táctil. Una pantalla táctil puede detectar solo los eventos de toque de un solo dedo. Una pantalla sin intervención del usuario no detecta los eventos de toque.|táctil, multitáctil, no táctil|
|`hw.sdCard`|**Compatibilidad con SDCard** &ndash; determina si el dispositivo emulado admite la inserción y eliminación de las tarjetas SD (Secure Digital) virtuales. El emulador usa imágenes de disco pueda montar almacenadas en el equipo de desarrollo para simular las particiones de los dispositivos de tarjeta SD reales (vea hw.sdCard.path).|sí, no|
|`sdcard.size`|**Tamaño de SDCard** &ndash; especifica el tamaño del archivo de tarjeta SD virtual en la ubicación especificada por `hw.sdCard.path`. está disponible en el dispositivo (en bytes). Si el tamaño es un entero simple, se especifica en bytes. También se puede especificar el tamaño en kilobytes, megabytes y gigabytes. Para ello, anexe K, M o G al tamaño. El tamaño mínimo es 9 M y el tamaño máximo es 1023 G.||
|`hw.sdCard.path`|**Ruta de acceso de imagen SDCard** &ndash; especifica el nombre de archivo y ruta de acceso a un archivo de imagen de partición de tarjeta SD en el equipo de desarrollo. Por ejemplo, se podría establecer esta ruta de acceso **C:\sd\sdcard.img** en Windows.||
|`hw.sensors.magnetic_field`|**Sensor de campo magnético** &ndash; determina si el dispositivo emulado admite un sensor de campo magnético. El sensor de campos magnético (también conocido como magnetómetro) notifica el campo geomagnético ambiental según las mediciones de tres ejes del sensor. Habilite esta opción para las aplicaciones que necesiten tener acceso a las lecturas de una brújula. Por ejemplo, una aplicación de navegación podría usar este sensor para detectar en qué dirección está orientado el usuario.|sí, no|
|`hw.sensors.orientation`|**Sensor de orientación** &ndash; determina si el dispositivo emulado proporciona orientación de los valores del sensor. El sensor de orientación mide los grados de rotación que realiza un dispositivo en torno a tres físicos ejes (x, y, z). Tenga en cuenta que el sensor de orientación está en desuso a partir de Android 2.2 (nivel de API 8).|sí, no|
|`hw.sensors.proximity`|**Sensor de proximidad** &ndash; determina si el dispositivo emulado admite un sensor de proximidad. Este sensor mide la proximidad de un objeto con respecto a la pantalla de un dispositivo. Este sensor suele usarse para determinar si se está sujetando un auricular junto a la oreja de una persona.|sí, no|
|`hw.sensors.temperature`|**Sensor de temperatura** &ndash; determina si el dispositivo emulado admite un sensor de temperatura. Este sensor mide la temperatura del dispositivo en grados centígrados (&deg;C).|sí, no|
|`hw.touchScreen`|**Compatibilidad con pantalla táctil** &ndash; determina si el dispositivo emulado admite una pantalla táctil. La pantalla táctil se usa para la manipulación directa de los objetos en la pantalla.|sí, no|
|`hw.trackBall`|**Compatibilidad de la bola de seguimiento** &ndash; determina si el dispositivo emulado admite una bola de seguimiento.|sí, no|
|`hw.useext4`|**Compatibilidad con sistema de archivos EXT4** &ndash; determina si el dispositivo emulado utiliza el sistema de archivos de Linux EXT4 de particiones. Dado que el tipo de sistema de archivos ahora se detecta automáticamente, esta opción está en desuso y se omite.|No|
|`kernel.newDeviceNaming`|**Nomenclatura de kernel nuevo dispositivo** &ndash; se utiliza para especificar si el núcleo requiere un nuevo esquema de nomenclatura de dispositivo. Se suele usar con kernels de Linux 3.10 y versiones posteriores. Si establece en **detección automática**, el emulador detectará automáticamente si el núcleo requiere un nuevo esquema de nomenclatura de dispositivo.|detección automática, sí, no|
|`kernel.parameters`|**Parámetros de kernel** &ndash; especifica la cadena de parámetros de inicio del kernel de Linux. De forma predeterminada, este valor se deja en blanco.||
|`kernel.path`|**Ruta de acceso de kernel** &ndash; especifica la ruta de acceso del kernel de Linux. Si no se especifica esta ruta de acceso, el emulador busca en el directorio de sistema de emulador de kernel ranchu.||
|`kernel.supportsYaffs2`|**Compatibilidad con las particiones YAFFS2** &ndash; determina si el núcleo admite YAFFS2 particiones (todavía otra Flash archivo sistema 2). Normalmente, esto solo se aplica a los kernels anteriores a Linux 3.10. Si establece en **detección automática** el emulador detectará automáticamente si el kernel puede montar sistemas de archivos YAFFS2.|detección automática, sí, no|
|`skin.name`|**Nombre de la máscara** &ndash; el nombre de una máscara del emulador de Android. Una máscara es una colección de archivos que define los elementos visuales y de control de una pantalla del emulador y describe el aspecto que tendrá la ventana del dispositivo virtual Android en el equipo de desarrollo. Una máscara describe el tamaño de la pantalla, los botones y el diseño global, pero no afecta al funcionamiento de la aplicación.||
|`skin.path`|**Ruta de acceso de la máscara** &ndash; ruta de acceso al directorio que contiene los archivos de máscara de emulador especificado en skin.name este directorio contiene archivos de diseño de hardware.ini y archivos de imagen para los elementos de visualización de la máscara.||
|`skin.dynamic`|**Máscara dinámicos** &ndash; o no la máscara es dinámica. La máscara del emulador es dinámica si el emulador va a construir una máscara de un tamaño determinado en función de una anchura y una altura especificadas.|No|

